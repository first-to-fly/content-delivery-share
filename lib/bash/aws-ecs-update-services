#!/usr/bin/env bash

source "${BASH_SOURCE[0]%/*}/core.sh"

dependency "aws"
dependency "envkey-source"

function main() {

  echo -e "${OK_COLOR}==> Updating AWS ECS services..."

  if [[ -z "${DEPLOY_ENVKEY:-}" && -f "./.env" ]]; then
    while IFS='' read -r LINE; do
      if [[ "${LINE}" == *"="* && "${LINE}" != "#"* ]]; then
        export "${LINE?}"
      fi
    done <"./.env"
  fi

  if [[ -z "${DEPLOY_ENVKEY:-}" ]]; then
    echo "Missing DEPLOY_ENVKEY." >&2
    return 1
  fi

  eval "$(envkey-source "${DEPLOY_ENVKEY}")"

  if [[ -z "${AWS_DEFAULT_REGION:-}" ]]; then
    local AWS_DEFAULT_REGION="us-east-1"
    export AWS_DEFAULT_REGION="${AWS_DEFAULT_REGION}"
  fi

  local CURRENT_BRANCH
  CURRENT_BRANCH="$(git rev-parse --abbrev-ref HEAD)"

  if [[ "${CURRENT_BRANCH}" != "${DEPLOY_BRANCH}" ]]; then
    echo "Current branch \"${CURRENT_BRANCH}\" is not marked for deployment." >&2
    return 0
  fi

  # If any AGENT is DISCONNECTED
  # (If true, tasks will be pending forever)
  echo
  echo "Checking for disconnected instances..."

  local CLUSTERS
  CLUSTERS="$(
    jq --raw-output '.[][]' <<<"${AWS_ECS_SERVICES:-[]}" |
      sed 's|/.*||g' |
      uniq
  )"

  local CLUSTER
  for CLUSTER in ${CLUSTERS}; do

    if
      aws ecs list-container-instances \
        --cluster "${CLUSTER}" |
        (grep "arn:" || true) |
        sed -e 's|.*"arn|arn|' -e 's|".*||' |
        xargs -I % aws ecs describe-container-instances \
          --cluster "${CLUSTER}" \
          --container-instances % |
        grep "agentConnected" |
        sed -e 's|.*: ||' -e 's|,||' |
        grep "false" \
        ;
    then
      echo "ERROR: At least one agent is disconnected." >&2
      return 1
    fi

  done

  local GIT_COMMIT_HASH
  GIT_COMMIT_HASH="$(git rev-parse --short HEAD)"

  local REMOTE_IMAGE="${AWS_ECS_REPO_URI}:${GIT_COMMIT_HASH}"
  echo "REMOTE_IMAGE = ${REMOTE_IMAGE}"

  local AWS_ECS_SERVICES_GROUP
  for AWS_ECS_SERVICES_GROUP in $(jq --compact-output '.[]' <<<"${AWS_ECS_SERVICES:-[]}"); do

    local WAIT_PIDS=""

    local AWS_ECS_SERVICE
    for AWS_ECS_SERVICE in $(jq --raw-output '.[]' <<<"${AWS_ECS_SERVICES_GROUP}"); do

      local CLUSTER
      CLUSTER="${AWS_ECS_SERVICE//\/*/}"

      local SERVICE
      SERVICE="${AWS_ECS_SERVICE//*\//}"

      echo
      echo "Updating [${CLUSTER}/${SERVICE}]..."

      # Update Task Definition with AWS_ECS_IMAGE_TAG
      local ACTIVE_TASK_DEFINITION_ARN
      ACTIVE_TASK_DEFINITION_ARN="$(
        aws ecs describe-services \
          --cluster "${CLUSTER}" \
          --service "${SERVICE}" |
          jq --raw-output '.services[0].taskDefinition'
      )"
      echo "ACTIVE_TASK_DEFINITION_ARN = ${ACTIVE_TASK_DEFINITION_ARN}"

      local TASK_DEFINITION_FAMILY_PREFIX="${ACTIVE_TASK_DEFINITION_ARN}"
      TASK_DEFINITION_FAMILY_PREFIX="${TASK_DEFINITION_FAMILY_PREFIX##*/}"
      TASK_DEFINITION_FAMILY_PREFIX="${TASK_DEFINITION_FAMILY_PREFIX%%:*}"
      echo "TASK_DEFINITION_FAMILY_PREFIX = ${TASK_DEFINITION_FAMILY_PREFIX}"

      # Latest
      local TASK_DEFINITION_ARN
      TASK_DEFINITION_ARN="$(
        aws ecs list-task-definitions --family-prefix "${TASK_DEFINITION_FAMILY_PREFIX}" |
          jq --raw-output '.taskDefinitionArns[-1]'
      )"
      echo "TASK_DEFINITION_ARN = ${TASK_DEFINITION_ARN}"

      local TASK_DEFINITION_JSON
      TASK_DEFINITION_JSON="$(
        aws ecs describe-task-definition \
          --task-definition "${TASK_DEFINITION_ARN}" |
          jq '.taskDefinition'
      )"
      # echo "TASK_DEFINITION_JSON = ${TASK_DEFINITION_JSON}"

      local TASK_DEFINITION_IMAGE
      TASK_DEFINITION_IMAGE="$(
        jq --raw-output '.containerDefinitions[0].image' <<<"${TASK_DEFINITION_JSON}"
      )"
      echo "TASK_DEFINITION_IMAGE = ${TASK_DEFINITION_IMAGE}"

      local NEW_TASK_DEFINITION_ARN

      # If current Task Definition uses our ECR (some like Redis uses global Docker Hub)
      if grep "${AWS_ECS_REPO_URI}" <<<"${TASK_DEFINITION_IMAGE}" >/dev/null; then

        if [[ "${TASK_DEFINITION_IMAGE}" != "${REMOTE_IMAGE}" ]]; then

          local NEW_TASK_DEFINITION_JSON
          NEW_TASK_DEFINITION_JSON="$(
            jq 'del(.taskDefinitionArn,.revision,.status,.requiresAttributes,.compatibilities)' <<<"${TASK_DEFINITION_JSON}" |
              sed -e "s|${TASK_DEFINITION_IMAGE}|${REMOTE_IMAGE}|g"
          )"

          local REGISTERED_TASK_DEFINITION_JSON
          REGISTERED_TASK_DEFINITION_JSON="$(
            aws ecs register-task-definition \
              --cli-input-json "${NEW_TASK_DEFINITION_JSON}"
          )"

          NEW_TASK_DEFINITION_ARN="$(
            jq --raw-output '.taskDefinition.taskDefinitionArn' <<<"${REGISTERED_TASK_DEFINITION_JSON}"
          )"

          echo "NEW_TASK_DEFINITION_ARN = ${NEW_TASK_DEFINITION_ARN:-}"

        fi

      fi

      if [[ -z "${NEW_TASK_DEFINITION_ARN:-}" && "${ACTIVE_TASK_DEFINITION_ARN}" != "${TASK_DEFINITION_ARN}" ]]; then
        NEW_TASK_DEFINITION_ARN="${TASK_DEFINITION_ARN}"
        TASK_DEFINITION_ARN="${ACTIVE_TASK_DEFINITION_ARN}"
      fi

      if [[ -n "${NEW_TASK_DEFINITION_ARN:-}" && "${NEW_TASK_DEFINITION_ARN}" != "${TASK_DEFINITION_ARN}" ]]; then

        # Update service
        set +e

        (
          set -x
          aws ecs update-service \
            --force-new-deployment \
            --cluster "${CLUSTER}" \
            --service "${SERVICE}" \
            --task-definition "${NEW_TASK_DEFINITION_ARN}" \
            >/dev/null
        )

        local UPDATE_SERVICE_EXIT_CODE=$?

        set -e

        local WAIT_PID=""

        if ((UPDATE_SERVICE_EXIT_CODE == 0)); then

          (
            set -x
            aws ecs wait services-stable \
              --cluster "${CLUSTER}" \
              --services "${SERVICE}"
          ) &

          WAIT_PID="$!"

        else
          # Service is deployed with CodeDeploy

          local CONTAINER_NAME
          CONTAINER_NAME="$(
            jq --raw-output '.containerDefinitions[0].name' <<<"${TASK_DEFINITION_JSON}"
          )"
          echo "CONTAINER_NAME = ${CONTAINER_NAME}"

          local CONTAINER_PORT
          CONTAINER_PORT="$(
            jq --raw-output '.containerDefinitions[0].portMappings[0].containerPort' <<<"${TASK_DEFINITION_JSON}"
          )"
          echo "CONTAINER_PORT = ${CONTAINER_PORT}"

          local APP_SPEC_CONTENT_TEMPLATE='
            {
              "version": 1,
              "Resources": [
                {
                  "TargetService": {
                    "Type": "AWS::ECS::Service",
                    "Properties": {
                      "TaskDefinition": "__TASK_DEFINITION_ARN__",
                      "LoadBalancerInfo": {
                        "ContainerName": "__CONTAINER_NAME__",
                        "ContainerPort": __CONTAINER_PORT__
                      }
                    }
                  }
                }
              ]
            }
          '
          # echo "APP_SPEC_CONTENT_TEMPLATE = ${APP_SPEC_CONTENT_TEMPLATE}"

          local APP_SPEC_CONTENT="${APP_SPEC_CONTENT_TEMPLATE}"
          APP_SPEC_CONTENT="${APP_SPEC_CONTENT//\"/\\\"}"
          APP_SPEC_CONTENT="${APP_SPEC_CONTENT//__TASK_DEFINITION_ARN__/${NEW_TASK_DEFINITION_ARN}}"
          APP_SPEC_CONTENT="${APP_SPEC_CONTENT//__CONTAINER_NAME__/${CONTAINER_NAME}}"
          APP_SPEC_CONTENT="${APP_SPEC_CONTENT//__CONTAINER_PORT__/${CONTAINER_PORT}}"
          echo "APP_SPEC_CONTENT = ${APP_SPEC_CONTENT}"

          local LAST_DEPLOYMENT_ID
          LAST_DEPLOYMENT_ID="$(
            aws deploy list-deployments \
              --application-name "AppECS-${CLUSTER}-${SERVICE}" \
              --deployment-group-name "DgpECS-${CLUSTER}-${SERVICE}" |
              jq --raw-output ".deployments[0]"
          )"

          while true; do
            local LAST_DEPLOYMENT_STATUS
            LAST_DEPLOYMENT_STATUS="$(
              aws deploy get-deployment --deployment-id "${LAST_DEPLOYMENT_ID}" |
                jq --raw-output '.deploymentInfo.status'
            )"
            if [[ "${LAST_DEPLOYMENT_STATUS}" == "InProgress" ]]; then
              echo "Last deployment ${LAST_DEPLOYMENT_ID} is still in progress..."
              sleep 15s
            else
              break
            fi
          done

          local DEPLOYMENT_ID
          DEPLOYMENT_ID="$(
            aws deploy create-deployment \
              --application-name "AppECS-${CLUSTER}-${SERVICE}" \
              --deployment-group-name "DgpECS-${CLUSTER}-${SERVICE}" \
              --revision "revisionType=\"AppSpecContent\",appSpecContent={content=\"${APP_SPEC_CONTENT}\"}" |
              jq --raw-output ".deploymentId"
          )"
          echo "DEPLOYMENT_ID = ${DEPLOYMENT_ID}"

          (
            while true; do
              local DEPLOYMENT_STATUS
              DEPLOYMENT_STATUS="$(
                aws deploy get-deployment --deployment-id "${DEPLOYMENT_ID}" |
                  jq --raw-output '.deploymentInfo.status'
              )"
              echo "Deployment ${DEPLOYMENT_ID} status is ${DEPLOYMENT_STATUS}..."
              case "${DEPLOYMENT_STATUS}" in
              Succeeded | Failed | Stopped)
                break
                ;;
              *)
                sleep 15s
                ;;
              esac
            done
          ) &

          # A deploy can take ~1 hour, so it's best not to wait!
          # (
          #   set -x
          #   aws deploy wait deployment-successful \
          #     --deployment-id "${DEPLOYMENT_ID}"
          # ) &

          WAIT_PID="$!"

        fi

        # Continue
        if [[ -n "${WAIT_PID:-}" ]]; then
          if [[ -n "${WAIT_PIDS:-}" ]]; then
            WAIT_PIDS="${WAIT_PIDS} ${WAIT_PID}"
          else
            WAIT_PIDS="${WAIT_PID}"
          fi
        fi

      fi

    done

    # Wait for all PIDs
    if [[ -n "${WAIT_PIDS:-}" ]]; then
      for WAIT_PID in ${WAIT_PIDS}; do
        echo "Waiting for process ${WAIT_PID}..."
        wait "${WAIT_PID}"
      done
    fi

  done

}

main "$@"
